// Copyright (C) 2020-2022 Intel Corporation
// SPDX-License-Identifier: MIT
//
// This file originally generated by etw_list
//     version:    main 3b12129f11805e7028772afc6263b7104dd2d3b4
//     parameters: --no_event_structs --event=QueueTimers::Info --event=QueueTimers::Start --event=QueueTimers::Stop --event=CpuGpuSync::Start --event=CpuGpuSync::Stop --event=ShaderCompilationTrackingEvents::Start --event=ShaderCompilationTrackingEvents::Stop --provider=Intel-Graphics-D3D10
#pragma once

namespace Intel_Graphics_D3D10 {

struct __declspec(uuid("{AD367E62-97EF-4B20-8235-E8AB49DB0C23}")) GUID_STRUCT;
static const auto GUID = __uuidof(GUID_STRUCT);

enum class Keyword : uint64_t {
    kCritical                        = 0x1,
    kDdiResourceFlow                 = 0x2,
    kPAVP                            = 0x4,
    kMonzaFenceTracking              = 0x8,
    kGenericDebug_Event              = 0x10,
    kGPA                             = 0x20,
    kResidency                       = 0x40,
    kKmthandle                       = 0x80,
    kThreadId                        = 0x100,
    kUmdalias                        = 0x200,
    kVa_Mapping                      = 0x400,
    kVa_Patching                     = 0x800,
    kVerbose                         = 0x1000,
    kDdi                             = 0x2000,
    kPrimitiveMaker                  = 0x4000,
    kDdiDevice                       = 0x8000,
    kDynamicBuffers                  = 0x10000,
    kQueueTimer_Event                = 0x20000,
    kCpuGpuSync_Event                = 0x40000,
    kGenericCpuPerf_Event            = 0x80000,
    kDiagnostic                      = 0x100000,
    kShaderCompilationTracking_Event = 0x200000,
    kShaderUsageTracking_Event       = 0x400000,
    kFrameInfo_Event                 = 0x800000,
    kSpeedFrame                      = 0x1000000,
    kIgcl                            = 0x2000000,
    kInternalAllocation_Event        = 0x8000000,
    cIntelGraphicsD3D10_Analytic     = 0x8000000000000000,
};

enum class Level : uint8_t {
    win_Critical      = 0x1,
    win_Error         = 0x2,
    win_Warning       = 0x3,
    win_Informational = 0x4,
    win_Verbose       = 0x5,
};

enum class Channel : uint8_t {
    cIntelGraphicsD3D10_Analytic = 0x10,
};

// Event descriptors:
#define EVENT_DESCRIPTOR_DECL(name_, id_, version_, channel_, level_, opcode_, task_, keyword_) struct name_ { \
    static uint16_t const Id      = id_; \
    static uint8_t  const Version = version_; \
    static uint8_t  const Channel = channel_; \
    static uint8_t  const Level   = level_; \
    static uint8_t  const Opcode  = opcode_; \
    static uint16_t const Task    = task_; \
    static Keyword  const Keyword = (Keyword) keyword_; \
};

// WORKAROUND: The manifest has the cIntelGraphicsD3D10_Analytic bit for EVERY
// event, so the provider setup will leave that bit in both the any and all
// mask.  That leads to all events being generated in the provider (driver)
// before being filtered by ETW based on event ID.  This has high CPU overhead.
// So, we manually remove this bit from all the event descriptors.
EVENT_DESCRIPTOR_DECL(CpuGpuSync_Start                       , 0x000f, 0x00, 0x10, 0x04, 0x01, 0x0003, 0x0000000000040000) // 0x8000000000040000)
EVENT_DESCRIPTOR_DECL(CpuGpuSync_Stop                        , 0x0010, 0x00, 0x10, 0x04, 0x02, 0x0003, 0x0000000000040000) // 0x8000000000040000)
EVENT_DESCRIPTOR_DECL(QueueTimers_Info                       , 0x003c, 0x00, 0x10, 0x04, 0x00, 0x0010, 0x0000000000020000) // 0x8000000000020000)
EVENT_DESCRIPTOR_DECL(QueueTimers_Start                      , 0x003b, 0x00, 0x10, 0x04, 0x01, 0x0010, 0x0000000000020000) // 0x8000000000020000)
EVENT_DESCRIPTOR_DECL(QueueTimers_Stop                       , 0x003d, 0x00, 0x10, 0x04, 0x02, 0x0010, 0x0000000000020000) // 0x8000000000020000)
EVENT_DESCRIPTOR_DECL(ShaderCompilationTrackingEvents_Start_3, 0x006b, 0x00, 0x10, 0x04, 0x01, 0x0012, 0x0000000000200000) // 0x8000000000200000)
EVENT_DESCRIPTOR_DECL(ShaderCompilationTrackingEvents_Start_4, 0x006d, 0x00, 0x10, 0x04, 0x01, 0x0012, 0x0000000000200000) // 0x8000000000200000)
EVENT_DESCRIPTOR_DECL(ShaderCompilationTrackingEvents_Stop_3 , 0x006c, 0x00, 0x10, 0x04, 0x02, 0x0012, 0x0000000000200000) // 0x8000000000200000)
EVENT_DESCRIPTOR_DECL(ShaderCompilationTrackingEvents_Stop_4 , 0x006e, 0x00, 0x10, 0x04, 0x02, 0x0012, 0x0000000000200000) // 0x8000000000200000)

// These added manually, only available in custom driver:
EVENT_DESCRIPTOR_DECL(task_DdiPresentDXGI_Info, 0x003f, 0x00, 0x10, 0x00, 0x00, 0x0012, 0x0000000000000010)
EVENT_DESCRIPTOR_DECL(task_FramePacer_Info,     0x0040, 0x00, 0x10, 0x00, 0x00, 0x0013, 0x0000000000000010)

#undef EVENT_DESCRIPTOR_DECL

enum class mSyncType : uint32_t {
    SYNC_TYPE_WAIT_SYNC_OBJECT_CPU = 0,
    SYNC_TYPE_WAIT_SYNC_OBJECT_GPU = 1,
    SYNC_TYPE_POLL_ON_QUERY_GET_DATA = 2,
    SYNC_TYPE_LAST = 3,
};

enum class mTimerType : uint32_t {
    WAIT_IF_FULL_TIMER = 0,
    WAIT_UNTIL_EMPTY_SYNC_TIMER = 1,
    WAIT_UNTIL_EMPTY_SYNC_ASYNC_TIMER = 2,
    WAIT_UNTIL_EMPTY_DRAIN_TIMER = 3,
    WAIT_UNTIL_EMPTY_DRAIN_ASYNC_TIMER = 4,
    WAIT_FOR_FENCE = 5,
    WAIT_UNTIL_FENCE_SUBMITTED = 6,
    WAIT_IF_EMPTY_TIMER = 7,
    FRAME_TIME_APP = 8,
    FRAME_TIME_DRIVER = 9,
    WAIT_TIMERS_COUNT = 10,
};

}
